/* Project ecosystem 1 by Daria Evseeva, Eduardo Vela, Nicolas Brich, Sarah Ertel, Constantin Holzapfel 21.1.19 */


/*
HELPER FUNCTIONS
*/

/*
Input: string
output: Array(Boolean)

from a string input into the filter gui, generates a boolean array with true
at the input index(-1) location or range
*/
function generate_bool_array(html_string){
  var split_string = html_string.split(";")
  var bool_array = Array(1000).fill(false)
  bool_array[0] = true

  split_string.forEach(function(elem){
    if (elem === "all"){
      bool_array = Array(1000).fill(true)
    }
    else if (elem.indexOf('-') > -1)
      {
        var range = elem.split("-")
        for(var i = +range[0]; i <= +range[1]; i++){
          bool_array[i] = true;
        }
      }
    else {
      bool_array[+elem] = true
    }
  }

  )
  return bool_array
}

/*
In: Object, Array(Boolean)
Out: Object

Given a boolean array and an object this function reduces the entries of the
object such that only entires for which the corresponding key-index returns true
in the boolean array.

*/
function filter_from_object(obj, bool_array){
  var obj_keys = Object.keys(obj);
  var out_obj = {}

  obj_keys =  obj_keys.filter(function(elem, idx){

    return bool_array[idx]
  })
  obj_keys.forEach(function(elem){
    out_obj[elem] = obj[elem];
  })
  //console.log(out_obj)
  return out_obj
}

/*
Helper function for use with Array.prototype.filter()

Sort logic for a supplied criterion (i.e. "Age", "Sex", "Nationality")
*/
function sort_by(sort_criterion){
  return function(x,y){
    return (x[sort_criterion] < y[sort_criterion]) ? -1 : (x[sort_criterion] > y[sort_criterion]) ? 1 : 0;
  }
}

/*
WRAPPER FUNCTION
in: filter-object, string
out: array OR object depending on input

Wrapper function which takes in a object generated by "filter_object" and a
string depending on use-case (i.e. "data", "metadata" or "pcoa"). Generates an
intersection of sample-IDs conforming to the selected filters and generates a
dataset (also depending on use-case) containing only the filterd samples.
*/

function filter_wrapper(filter_obj,meta_switch){

  // fetch filter inputs from the html user interface
  var age_from_val = +document.getElementById("FROM").value;
  var age_to_val = +document.getElementById("TO").value;
  var sex_val = document.getElementById("btn_sex").value;
  var nationality_val = document.getElementById("btn_nationality").value;
  var bmi_val = document.getElementById("btn_bmi").value;

  //fetch sort order from html user interface
  var sort_val = document.getElementById("btn_sortby").value;

  //fetch column sort string from hrml user interface
  var keep_cols = document.getElementById("COLS").value;

  //calculte the SampleID-lists from the fetched filteres
  var age_filter = filter_obj.generic_filter("Age",[age_from_val,age_to_val])
  var sex_filter = filter_obj.generic_filter("Sex",sex_val)
  var nationality_filter = filter_obj.generic_filter("Nationality",nationality_val)
  var bmi_filter = filter_obj.generic_filter("BMI_group",bmi_val)

  //calculate intersection of the previously generated SampleID lists
  var filtered_objects = filter_obj.intersection([age_filter,sex_filter,nationality_filter,bmi_filter])

  //sort the samples by the fetched sort logic (only if not in PCoA mode)
  if(!(meta_switch === "pcoa")){
    filtered_objects = filtered_objects.sort(sort_by(sort_val))
  }

  //generate Array for filtering of columns
  var bool_array = generate_bool_array(keep_cols)

  var filter_sampleIDs = []
  filtered_objects.forEach(function(elem){
    filter_sampleIDs.push(elem.SampleID)
  })

  //depending on the use case calculate the final dataset
  switch (meta_switch) {
    case "Data":
      var filtered_data = filter_obj.filter_data(filter_sampleIDs,bool_array)
      return filtered_data
      break;
    case "Meta":
      var filtered_data = filter_obj.filter_metadata(filter_sampleIDs)
      return filtered_data
      break;
    case "pcoa":
      var filtered_data = filter_obj.filter_data(filter_sampleIDs)
      var filtered_meta_data = filter_obj.filter_metadata(filter_sampleIDs)
      filtered_data["metadataOverview"] = filtered_meta_data
      return filtered_data
      break;
    default:
      var filtered_data = filter_obj.filter_data(filter_sampleIDs)
      return filtered_data

  }

}

/*
OBJECT FUNCTION
Input: object, boolean
Output: Array or OBJECT

Constructor function for the filter object.
Data for the corresponding site type (i.e. Metadata, data, or pcoa-data) is
supplied and the filter-type is choosen via boolean (i.e. false for data and
metadata, true for PCoA). Filtering operations are then performed by using the
generated object in conjuction with the wrapper function.
*/

function filter_object(data,pcoa_switch){
  var returnDictionary = {};

  //debugging command
  returnDictionary["select_category"] = function(selector){
    console.log(data["metadataOverview"][selector])
    }
  // given a metadata category and a fitting criterion generate a list of IDs
  // which fits to the given filter criterions
  returnDictionary["generic_filter"] = function(category,filter_criterion){
    filtered_samples = []
    switch (category) {

      case "Age":
      if(filter_criterion === "all"){
        filtered_samples = data["metadataOverview"]
      }
      else{
        for (i = 0; i < data["metadataOverview"].length; i++){
          if(data["metadataOverview"][i][category] >= filter_criterion[0] && data["metadataOverview"][i][category] <= filter_criterion[1]){
              filtered_samples.push(data["metadataOverview"][i])
            }
          }
        }
        break;

      case "Sex":
      case "Nationality":
      case "BMI_group":
      if(filter_criterion === "all"){
        filtered_samples = data["metadataOverview"]
      }
      else{
        for (i = 0; i < data["metadataOverview"].length; i++){
          if(data["metadataOverview"][i][category] === filter_criterion){
              filtered_samples.push(data["metadataOverview"][i])
            }
          }
        }
        break;
      default:
        console.log("ERROR WRONG CATEGORY")
      }
    return filtered_samples
    }
  //calculate the intersection of all Id-lists which are contained in the
  // id-array
  returnDictionary["intersection"] = function(id_array){
    var internal_array = id_array
    while(internal_array.length > 1){
      internal_array[internal_array.length-2] = internal_array[internal_array.length-1].filter(
        a => internal_array[internal_array.length-2].some( b => a.SampleID === b.SampleID ) );
      internal_array.pop()
    }
    return internal_array[0]

  }
  // as the data-structur is different for the PCoA to different functions
  // are used for the dataset Filtering

  if(pcoa_switch){

    //generates an object which contains the filtered dataset for use with the
    // pcoa functions
    returnDictionary["filter_data"] = function(sample_ids){
      var sample_ids = sample_ids;
      var data_internal = data["dataExploration"];
      var object_internal = {"dataExploration":data["dataExploration"],
                            "PCsPercentage":data["PCsPercentage"],
                            "metadataOverview":data["metadataOverview"]};
      var out_obj = {}
      //out_array = out_array.filter(row => sample_ids.includes(row[""]))

      sample_ids.forEach(function(elem){
        out_obj[elem] = data_internal[elem]
          }
        )
      object_internal["dataExploration"] = out_obj
      return object_internal
      }
  }

  else{
    // returns the dataExploration dataset filtered for the sample_ids
    returnDictionary["filter_data"] = function(sample_ids,bool_arr){
    var sample_ids = sample_ids;
    var data_internal = data["dataExploration"];
    var out_array = []


    sample_ids.forEach(function(elem){
      for(var i = 0; i < data_internal.length; i++){
        if(data_internal[i][""] === elem){
          out_array.push(filter_from_object(data_internal[i], bool_arr))
          break;
        }
      }
    })

    return out_array
    }
  }

  // returns the metadataOverview dataset filtered for the sampleIds
  returnDictionary["filter_metadata"] = function(sample_ids){
    var sample_ids = sample_ids;
    var metadata_internal = data["metadataOverview"];
    var out_array = []
    //out_array = out_array.filter(row => sample_ids.includes(row["SampleID"]))
    sample_ids.forEach(function(elem){
      for(var i = 0; i < metadata_internal.length; i++){
        if(metadata_internal[i]["SampleID"] === elem){
          out_array.push(metadata_internal[i])
          break;
        }
      }
    })

    return out_array
    }
  return returnDictionary
  }
